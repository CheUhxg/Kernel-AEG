diff --git a/.gitignore b/.gitignore
index b33fbbf93237..2350382c64b9 100644
--- a/.gitignore
+++ b/.gitignore
@@ -68,3 +68,5 @@ pythonenv*
 /clang/utils/analyzer/projects/*/RefScanBuildResults
 # automodapi puts generated documentation files here.
 /lldb/docs/python_api/
+
+/test
\ No newline at end of file
diff --git a/llvm/lib/Transforms/CMakeLists.txt b/llvm/lib/Transforms/CMakeLists.txt
index dda5f6de11e3..9d6eb1941efa 100644
--- a/llvm/lib/Transforms/CMakeLists.txt
+++ b/llvm/lib/Transforms/CMakeLists.txt
@@ -9,3 +9,4 @@ add_subdirectory(Hello)
 add_subdirectory(ObjCARC)
 add_subdirectory(Coroutines)
 add_subdirectory(CFGuard)
+add_subdirectory(CapabilityLog)
diff --git a/llvm/lib/Transforms/CMakeLists.txt.rej b/llvm/lib/Transforms/CMakeLists.txt.rej
new file mode 100644
index 000000000000..92ad95f7cb3a
--- /dev/null
+++ b/llvm/lib/Transforms/CMakeLists.txt.rej
@@ -0,0 +1,7 @@
+--- llvm/lib/Transforms/CMakeLists.txt
++++ llvm/lib/Transforms/CMakeLists.txt
+@@ -9,4 +9,3 @@ add_subdirectory(Hello)
+ add_subdirectory(ObjCARC)
+ add_subdirectory(Coroutines)
+ add_subdirectory(CFGuard)
+-add_subdirectory(Obfuscation)
diff --git a/llvm/lib/Transforms/CapabilityLog/CMakeLists.txt b/llvm/lib/Transforms/CapabilityLog/CMakeLists.txt
new file mode 100644
index 000000000000..9c4b495f969d
--- /dev/null
+++ b/llvm/lib/Transforms/CapabilityLog/CMakeLists.txt
@@ -0,0 +1,36 @@
+file(GLOB SOURCES
+CapabilityLog.cpp)
+
+include_directories(SYSTEM ${LLVM_INCLUDE_DIRS})
+link_directories(${LLVM_LIB_DIRS})
+
+set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -DLLVM_MAJOR_VERSION=${LLVM_VERSION_MAJOR}")
+
+# generate MyPass.so
+# add_llvm_pass_plugin must be used with AddLLVM
+add_llvm_pass_plugin(LLVMCapabilityLog
+	${SOURCES}
+)
+
+add_dependencies(LLVMCapabilityLog intrinsics_gen)
+
+set_target_properties(LLVMCapabilityLog PROPERTIES
+						RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)
+
+# generate libMyPass.so
+# add_library(MyPass
+#	SHARED
+#	MyPass.cpp
+#)
+
+
+# clang-12 -Xclang -load -Xclang /media/hdisk2/MyPass/libMyPass.so -mllvm -slice -c test.c
+# clang-14 -flegacy-pass-manager -Xclang -load -Xclang /media/hdisk2/MyPass/libMyPass.so -mllvm -slice -c test.c
+
+# for new pass manager, use "-fplugin Bye.so" or "-Xclang -load -Xclang Bye.so" to allow passing cmd arguments.
+# for clang-12, we can also use "-fplugin MyPass.so" to replace "-Xclang ...".
+# for clang-12, use "-fexperimental-new-pass-manager -fplugin xxx -fpass-plugin xxx" to run with new pass manager.
+# use "-O1" for Bye.so because Bye pass does not run on optnone functions.
+# clang-14 -fplugin=Bye.so -fpass-plugin=Bye.so -mllvm -wave-goodbye -c ../test.c
+
+# using opt, both "-load xxx" and "--load-pass-plugin=xxx" should be used to use cmd arguments
diff --git a/llvm/lib/Transforms/CapabilityLog/CapabilityLog.cpp b/llvm/lib/Transforms/CapabilityLog/CapabilityLog.cpp
new file mode 100644
index 000000000000..0ba22b74fbc8
--- /dev/null
+++ b/llvm/lib/Transforms/CapabilityLog/CapabilityLog.cpp
@@ -0,0 +1,422 @@
+#include "llvm/ADT/APFloat.h"
+#include "llvm/ADT/StringRef.h"
+#include "llvm/ADT/Twine.h"
+#include "llvm/Analysis/AliasAnalysis.h"
+#include "llvm/Analysis/BasicAliasAnalysis.h"
+#include "llvm/Analysis/CallGraph.h"
+#include "llvm/Analysis/LoopInfo.h"
+#include "llvm/Analysis/ScalarEvolution.h"
+#include "llvm/Analysis/TargetLibraryInfo.h"
+#include "llvm/Bitcode/BitcodeWriter.h"
+#include "llvm/IR/BasicBlock.h"
+#include "llvm/IR/Constant.h"
+#include "llvm/IR/Constants.h"
+#include "llvm/IR/DataLayout.h"
+#include "llvm/IR/DerivedTypes.h"
+#include "llvm/IR/Dominators.h"
+#include "llvm/IR/Function.h"
+#include "llvm/IR/IRBuilder.h"
+#include "llvm/IR/InstrTypes.h"
+#include "llvm/IR/Instruction.h"
+#include "llvm/IR/Instructions.h"
+#include "llvm/IR/Intrinsics.h"
+#include "llvm/IR/LLVMContext.h"
+#include "llvm/IR/LegacyPassManager.h"
+#include "llvm/IR/Metadata.h"
+#include "llvm/IR/Module.h"
+#include "llvm/IR/Type.h"
+#include "llvm/IR/Value.h"
+#include "llvm/Pass.h"
+#include "llvm/Passes/PassBuilder.h"
+#include "llvm/Support/Casting.h"
+#include "llvm/Support/ErrorHandling.h"
+#include "llvm/Support/Format.h"
+#include "llvm/Support/InstructionCost.h"
+#include "llvm/Support/JSON.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/Transforms/IPO/PassManagerBuilder.h"
+
+#include <cstddef>
+#include <cstdint>
+#include <unordered_map>
+#include <unordered_set>
+#include <vector>
+
+using namespace llvm;
+using namespace std;
+
+namespace {
+struct LLVMCapabilityLogOnFunction : public FunctionPass {
+public:
+    static char ID;
+    
+    LLVMCapabilityLogOnFunction() : FunctionPass(ID) {
+        ErrorOr<unique_ptr<MemoryBuffer>> FileOrErr = MemoryBuffer::getFile(JsonPath);
+        if (error_code EC = FileOrErr.getError()) {
+            errs() << "Error reading file: " << EC.message() << "\n";
+            return;
+        }
+
+        Expected<json::Value> ParsedOrErr = json::parse(FileOrErr.get()->getBuffer());
+        if (!ParsedOrErr) {
+            errs() << "Error parsing JSON: " << toString(ParsedOrErr.takeError()) << "\n";
+            return;
+        }
+
+        JsonObj = ParsedOrErr->getAsObject();
+        if (!JsonObj) {
+            errs() << "Error: JSON is not an object\n";
+            return;
+        }
+
+        for (const auto &StructEntry : *JsonObj) {
+            const json::Array* CopyArr = StructEntry.second.getAsObject()->getArray("copy");
+            const json::Array* AllocArr = StructEntry.second.getAsObject()->getArray("alloc");
+            if (CopyArr == nullptr || CopyArr->empty() || AllocArr == nullptr || AllocArr->empty())
+                continue;
+
+            auto &ObjInf = St2Info[StructEntry.first.str()];
+            ObjInf.IsBridge = StructEntry.second.getAsObject()->getBoolean("bridge").getValue();
+            ObjInf.IsRouter = StructEntry.second.getAsObject()->getBoolean("router").getValue();
+            ObjInf.Index = StructEntry.second.getAsObject()->getInteger("index").getValue();
+            for (const auto &PathEntry : *CopyArr) {
+                ObjInf.CopyFuncs.insert(PathEntry.getAsString()->str());
+            }
+            for (const auto &PathEntry : *AllocArr) {
+                ObjInf.AllocFuncs.insert(PathEntry.getAsString()->str());
+            }
+        }
+    }
+    
+    bool DebugMod = false;
+    bool runOnFunction(Function& F) override {
+        bool Ret = false;
+        unordered_set<string> StNames;
+
+        // if (F.getName().equals("alloc_msg")) DebugMod = true;
+        findStructByFunction(F.getName(), StNames);
+        if (StNames.empty()) {
+            DebugMod = false;
+            return false;
+        }
+        errs() << "[*] " << F.getName() << "\n";
+if (DebugMod) errs() << F << "\n";
+
+        for (auto &BB : F) {
+            for (auto &I : BB) {
+                CallInst *CI = dyn_cast<CallInst>(&I);
+                if (CI == nullptr)
+                    continue;
+
+                StringRef CallFuncName = CI->getCalledOperand()->getName();
+
+                if (CallFuncName.contains("alloc") && 
+                    CallFuncName.startswith("k") &&
+                    !CallFuncName.contains("cache")) {
+if (DebugMod) errs() << "[CF] " << CallFuncName << "\n";
+                    Ret = insertAlloc(CI, StNames);
+                }
+                else if (CallFuncName.contains("memcpy") ||
+                    CallFuncName.contains("copy_from_user")) {
+if (DebugMod) errs() << "[CF] " << CallFuncName << "\n";
+                    Ret = insertCopy(CI, StNames);
+                }
+
+            }
+        }
+        if (!Ret) errs() << "[-] " << F.getName() << "\n";
+        else errs() << "[+] " << F.getName() << "\n";
+        DebugMod = false;
+        return Ret;
+    }
+
+private:
+    const string JsonPath = "/home/user/Tools/w2l/code/out/defdebug/dumpResults/merged_output.json";
+    json::Object* JsonObj;
+
+    struct ObjectInfo {
+        bool IsBridge = false, IsRouter = false;
+        uint8_t Index;
+        unordered_set<string> CopyFuncs;
+        unordered_set<string> AllocFuncs;
+    };
+    unordered_map<string, struct ObjectInfo> St2Info;
+
+    void findObjSources(Value* V, std::vector<llvm::Value *> &SrcSet) {
+        if (dyn_cast<Constant>(V) != nullptr) {
+            return;
+        }
+
+        if (LoadInst* LI = dyn_cast<LoadInst>(V)) {
+
+            SrcSet.push_back(V);
+
+            // alias handling
+            Function *F = LI->getFunction();
+
+            if(!F) return;
+
+            findObjSources(LI->getPointerOperand(), SrcSet);
+            return;
+        }
+
+        if (GetElementPtrInst* GEP = dyn_cast<GetElementPtrInst>(V)) {
+            SrcSet.push_back(V);
+            // Heuristic 2: first GEP is enough?
+            // Lewis: Wrong
+            findObjSources(GEP->getPointerOperand(), SrcSet);
+            return;
+        }
+
+        // Lewis: this guess hits, add one chicken leg tonight!
+        if (CallInst* CI = dyn_cast<CallInst>(V)) {
+            // Storing callInst helps to check from value type
+            SrcSet.push_back(V);
+            // Heuristic 1: calling to strlen()/vmalloc() isn't what we want
+            const Function* Callee = CI->getCalledFunction();
+            if (Callee != nullptr) {
+                std::string calleeName = Callee->getName().str();
+                if (calleeName == "strlen"||
+                    calleeName == "vmalloc")
+                    return;
+            }
+
+            if(!Callee) return;
+            // interprocedural analysis
+            for(const BasicBlock &BB : *Callee){
+                for(const Instruction &I : BB){
+                    if(const ReturnInst *RI = dyn_cast<ReturnInst>(&I)){
+                        if(Value *rValue = RI->getReturnValue()){
+                            findObjSources(rValue, SrcSet);
+                        }
+                    }
+                }
+            }
+            return;
+        }
+
+        if (ZExtInst* ZI = dyn_cast<ZExtInst>(V)) {
+            findObjSources(ZI->getOperand(0), SrcSet);
+            return;
+        }
+
+        if (TruncInst* TI = dyn_cast<TruncInst>(V)) {
+            findObjSources(TI->getOperand(0), SrcSet);
+            return;
+        }
+
+        if (BinaryOperator* BO = dyn_cast<BinaryOperator>(V)) {
+            for (unsigned i = 0, e = BO->getNumOperands(); i != e; i++) {
+                Value* Opd = BO->getOperand(i);
+                if (dyn_cast<Constant>(Opd) != nullptr)
+                    continue;
+                findObjSources(Opd, SrcSet);
+            }
+            return;
+        }
+
+        if(BitCastInst *BCI = dyn_cast<BitCastInst>(V)){
+            SrcSet.push_back(V);
+            findObjSources(BCI->getOperand(0), SrcSet);
+            return;
+        }
+
+        return;
+    }
+
+    string getAllocStName(CallInst *CI, const unordered_set<string> &StNames) {
+        if (CI->getNumOperands() < 2) return "";
+
+        StructType *StType = nullptr;
+        string StName;
+        for (auto *CallUser : CI->users()) {
+            if (auto *BCI = dyn_cast<BitCastInst>(CallUser)) {
+                PointerType* PtrType = dyn_cast<PointerType>(BCI->getDestTy());
+                Type* BaseType = PtrType->getPointerElementType();
+                StType = dyn_cast<StructType>(BaseType);
+                if (StType == nullptr)
+                    continue;
+                StName = StType->getStructName().str();
+                if (StNames.count(StName))break;
+                StName = "";
+            }
+            if (auto *SI = dyn_cast<StoreInst>(CallUser)) {
+                if (auto *GEP = dyn_cast<GetElementPtrInst>(SI->getPointerOperand())) {
+                    Type *BaseType = GEP->getSourceElementType();
+                    StType = dyn_cast<StructType>(BaseType);
+                    if (StType == nullptr)
+                        continue;
+                    StName = StType->getStructName().str();
+                    if (StNames.count(StName))break;
+                    StName = "";
+                }
+            }
+        }
+        return StName;
+    }
+
+    string getCopyStName(CallInst *CI, const unordered_set<string> &StNames) {
+        Value *Key = nullptr;
+        for (const string &StructName : StNames) {
+            if (St2Info[StructName].IsBridge) Key = CI->getArgOperand(2);
+            else Key = CI->getArgOperand(0);
+            vector<llvm::Value *> KeySet;
+
+            if (dyn_cast<ConstantInt>(Key) != nullptr)
+                continue;
+
+            findObjSources(Key, KeySet);
+            for (std::vector<llvm::Value*>::iterator i = KeySet.begin(), 
+                e = KeySet.end(); i != e; i++) {
+                Value *V = *i;
+                if(auto *LI = dyn_cast<LoadInst>(V)) {
+                    // check if it's loading a pointer
+                    if(LI->getPointerOperandType()->getPointerElementType()->isPointerTy()){
+                        continue;
+                    }
+
+                    if(GetElementPtrInst *GEP = dyn_cast<GetElementPtrInst>(LI->getPointerOperand())){
+                        if (!GEP->getPointerOperandType()->getNonOpaquePointerElementType()->isStructTy())
+                            continue;
+                        if (GEP->getSourceElementType()->getStructName() == StructName)
+                            return StructName;
+                    }
+                }
+                else if (auto *BCI = dyn_cast<BitCastInst>(V)) {
+                    StructType *StTy = dyn_cast<StructType>(BCI->getSrcTy()->getPointerElementType());
+                    if (StTy == nullptr || StTy->getStructName() != StructName)
+                        continue;
+                    return StructName;
+                }
+            }
+        }
+        return "";
+    }
+
+    FunctionCallee getLogCapFunction(Module &M) {
+        LLVMContext &Context = M.getContext();
+        FunctionCallee LogCapFunction = M.getFunction("log_cap");
+
+        if (!LogCapFunction) {
+            // 声明函数 log_cap
+            Type *VoidTy = Type::getVoidTy(Context);
+            Type *Int8PtrTy = Type::getInt8PtrTy(Context);
+            Type *Int64Ty = Type::getInt64Ty(Context);
+            Type *UInt8Ty = Type::getInt8Ty(Context);
+
+            std::vector<Type *> ParamTypes = {Int8PtrTy, Int8PtrTy, Int64Ty, UInt8Ty};
+            FunctionType *FuncType = FunctionType::get(VoidTy, ParamTypes, false);
+
+            LogCapFunction = M.getOrInsertFunction("log_cap", FuncType);
+        }
+
+        return LogCapFunction;
+    }
+
+    void insertCall(CallInst *CI, Value *Dst, Value *Src, Value *Len, const string &StName) {
+        BasicBlock *BB = CI->getParent();
+        Module *M = BB->getModule();
+        LLVMContext &Context = M->getContext();
+
+        IRBuilder<> Builder(Context);
+        Builder.SetInsertPoint(CI);
+
+        FunctionCallee LogCapFunction = getLogCapFunction(*M);
+
+        IntegerType *UInt8Ty = IntegerType::getInt16Ty(CI->getContext());
+        unsigned Index = St2Info[StName].Index;
+        ConstantInt *Hash = ConstantInt::get(UInt8Ty, Index, false);
+        errs() << "[H] " << StName << ":#" << Index << "\n";
+
+        std::vector<Value *> Args = {Dst, Src, Len, Hash};
+        Builder.CreateCall(LogCapFunction, Args);
+    }
+
+    bool insertAlloc(CallInst *CI, const unordered_set<string> &StNames) {
+        string StName = getAllocStName(CI, StNames);
+        if (StName.empty())
+            return false;
+
+        PointerType *PointerTy = PointerType::getInt8PtrTy(CI->getContext());
+        Value *Dst = Constant::getNullValue(PointerTy);
+        Value *Src = Constant::getNullValue(PointerTy);
+        Value *Len = CI->getArgOperand(0);
+
+        insertCall(CI, Dst, Src, Len, StName);
+        return true;
+    }
+
+    bool insertCopy(CallInst *CI, const unordered_set<string> &StNames) {
+        string StName = getCopyStName(CI, StNames);
+        if (StName.empty())
+            return false;
+
+        Value *Dst = CI->getArgOperand(0);
+        Value *Src = CI->getArgOperand(1);
+        Value *Len = CI->getArgOperand(2);
+
+        insertCall(CI, Dst, Src, Len, StName);
+        return true;
+    }
+
+    void findStructByFunction(const StringRef FuncName, unordered_set<string> &StNames) const {
+        for (auto s2i : St2Info) {
+            for (auto &Func : s2i.second.CopyFuncs) {
+                if (FuncName.equals(Func)) {
+                    StNames.insert(s2i.first);
+                }
+            }
+            for (auto &Func : s2i.second.AllocFuncs) {
+                if (FuncName.equals(Func)) {
+                    StNames.insert(s2i.first);
+                }
+            }
+        }
+        return;
+    }
+};
+
+struct LLVMGenerateBitCodeOnModule : public ModulePass {
+public:
+    static char ID;
+
+    LLVMGenerateBitCodeOnModule() : ModulePass(ID) {}
+
+    bool runOnModule(Module& M) override {
+        errs() << "[M] " << M.getName() << "\n";
+        return false;
+    }
+};
+
+char LLVMCapabilityLogOnFunction::ID = 0;
+static RegisterPass<LLVMCapabilityLogOnFunction> XF("log-cap-function", "Log Capability Function Pass");
+static llvm::RegisterStandardPasses YF(
+    llvm::PassManagerBuilder::EP_EarlyAsPossible,
+    [](const llvm::PassManagerBuilder &KmallocBuilder,
+       llvm::legacy::PassManagerBase &PM) { PM.add(new LLVMCapabilityLogOnFunction()); });
+} // namespace
+
+// namespace {
+// struct LLVMCapabilityLogOnModule : public ModulePass {
+// public:
+//     static char ID;
+    
+//     LLVMCapabilityLogOnModule() : ModulePass(ID) {}
+    
+//     bool runOnModule(Module& M) override {
+//         for (auto &F : M) {
+//             errs() << "Found a func: " << F.getName() << "\n";
+//         }
+//         return false;
+//     }
+// };
+
+// char LLVMCapabilityLogOnModule::ID = 0;
+// static RegisterPass<LLVMCapabilityLogOnModule> XM("trace-malloc-module", "Trace Malloc Module Pass");
+// static llvm::RegisterStandardPasses YM(
+//     llvm::PassManagerBuilder::EP_EnabledOnOptLevel0,
+//     [](const llvm::PassManagerBuilder &KmallocBuilder,
+//        llvm::legacy::PassManagerBase &PM) { PM.add(new LLVMCapabilityLogOnModule()); });
+
+// } // namespace
+
diff --git a/llvm/lib/Transforms/IPO/CMakeLists.txt.rej b/llvm/lib/Transforms/IPO/CMakeLists.txt.rej
new file mode 100644
index 000000000000..4c24f2cabee1
--- /dev/null
+++ b/llvm/lib/Transforms/IPO/CMakeLists.txt.rej
@@ -0,0 +1,8 @@
+--- llvm/lib/Transforms/IPO/CMakeLists.txt
++++ llvm/lib/Transforms/IPO/CMakeLists.txt
+@@ -73,5 +73,4 @@ add_llvm_component_library(LLVMipo
+   Vectorize
+   Instrumentation
+   Scalar
+-  Obfuscation
+   )
diff --git a/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp b/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
index 2a6e38b0437f..a823d65498a4 100644
--- a/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
+++ b/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
@@ -50,6 +50,10 @@
 #include <utility>
 #include <vector>
 
+#include "llvm/Bitcode/BitcodeWriter.h"
+#include "llvm/Support/ToolOutputFile.h"
+#include "llvm/Support/FileSystem.h"
+
 using namespace llvm;
 
 #define DEBUG_TYPE "deadargelim"
@@ -1088,6 +1092,18 @@ bool DeadArgumentEliminationPass::RemoveDeadStuffFromFunction(Function *F) {
 
 PreservedAnalyses DeadArgumentEliminationPass::run(Module &M,
                                                    ModuleAnalysisManager &) {
+  std::string FileName = M.getSourceFileName();
+  if (FileName.find(".c") != FileName.npos) {
+    std::string Path = M.getSourceFileName() + ".bc";
+    outs() << "[+] Writing to " << Path << "\n";
+    std::error_code EC;
+    raw_fd_ostream out(Path, EC, sys::fs::OF_None);
+    WriteBitcodeToFile(M, out);
+    out.flush();
+    out.close();
+    outs() << "[+] Write done\n";
+  }
+
   bool Changed = false;
 
   // First pass: Do a simple check to see if any functions can have their "..."
diff --git a/llvm/lib/Transforms/IPO/PassManagerBuilder.cpp.rej b/llvm/lib/Transforms/IPO/PassManagerBuilder.cpp.rej
new file mode 100644
index 000000000000..5b80892589d0
--- /dev/null
+++ b/llvm/lib/Transforms/IPO/PassManagerBuilder.cpp.rej
@@ -0,0 +1,99 @@
+--- llvm/lib/Transforms/IPO/PassManagerBuilder.cpp
++++ llvm/lib/Transforms/IPO/PassManagerBuilder.cpp
+@@ -52,13 +52,6 @@
+ #include "llvm/Transforms/Vectorize/SLPVectorizer.h"
+ #include "llvm/Transforms/Vectorize/VectorCombine.h"
+ 
+-#include "llvm/Transforms/Obfuscation/BogusControlFlow.h"
+-#include "llvm/Transforms/Obfuscation/Flattening.h"
+-#include "llvm/Transforms/Obfuscation/Split.h"
+-#include "llvm/Transforms/Obfuscation/Substitution.h"
+-#include "llvm/Transforms/Obfuscation/StringObfuscation.h"
+-#include "llvm/Transforms/Obfuscation/CryptoUtils.h"
+-
+ using namespace llvm;
+ 
+ namespace llvm {
+@@ -155,28 +148,6 @@ cl::opt<bool>
+     EnableGVNSink("enable-gvn-sink", cl::init(false), cl::ZeroOrMore,
+                   cl::desc("Enable the GVN sinking pass (default = off)"));
+ 
+-// Flags for obfuscation
+-static cl::opt<bool> Flattening("fla", cl::init(false),
+-                                cl::desc("Enable the flattening pass"));
+-
+-static cl::opt<bool> BogusControlFlow("bcf", cl::init(false),
+-                                      cl::desc("Enable bogus control flow"));
+-
+-static cl::opt<bool> Substitution("sub", cl::init(false),
+-                                  cl::desc("Enable instruction substitutions"));
+-
+-static cl::opt<std::string> AesSeed("aesSeed", cl::init(""),
+-                                    cl::desc("seed for the AES-CTR PRNG"));
+-
+-static cl::opt<bool> Split("split", cl::init(false),
+-                           cl::desc("Enable basic block splitting"));
+-
+-static cl::opt<std::string> Seed("seed", cl::init(""),
+-                           cl::desc("seed for the random"));
+-
+-static cl::opt<bool> StringObf("sobf", cl::init(false),
+-                           cl::desc("Enable the string obfuscation"));
+-
+ // This option is used in simplifying testing SampleFDO optimizations for
+ // profile loading.
+ cl::opt<bool>
+@@ -249,21 +220,6 @@ PassManagerBuilder::PassManagerBuilder() {
+     PerformThinLTO = EnablePerformThinLTO;
+     DivergentTarget = false;
+     CallGraphProfile = true;
+-
+-    // Initialization of the global cryptographically
+-    // secure pseudo-random generator
+-    if(!AesSeed.empty()) {
+-        if(!llvm::cryptoutils->prng_seed(AesSeed.c_str())) {
+-          exit(1);
+-        }
+-    }
+-
+-    //random generator
+-    if(!Seed.empty()) {
+-        if(!llvm::cryptoutils->prng_seed(Seed.c_str()))
+-          exit(1);
+-    }
+-
+ }
+ 
+ PassManagerBuilder::~PassManagerBuilder() {
+@@ -737,14 +693,6 @@ void PassManagerBuilder::populateModulePassManager(
+   // Allow forcing function attributes as a debugging and tuning aid.
+   MPM.add(createForceFunctionAttrsLegacyPass());
+ 
+-  MPM.add(createSplitBasicBlock(Split));
+-  MPM.add(createBogus(BogusControlFlow));
+-  #if LLVM_VERSION_MAJOR >= 9
+-    MPM.add(createLowerSwitchPass());
+-  #endif
+-  MPM.add(createFlattening(Flattening));
+-  MPM.add(createStringObfuscation(StringObf));
+-
+   // If all optimizations are disabled, just run the always-inline pass and,
+   // if enabled, the function merging pass.
+   if (OptLevel == 0) {
+@@ -773,8 +721,6 @@ void PassManagerBuilder::populateModulePassManager(
+       MPM.add(createGlobalDCEPass());
+     }
+ 
+-    MPM.add(createSubstitution(Substitution));
+-
+     addExtensionsToPM(EP_EnabledOnOptLevel0, MPM);
+ 
+     if (PrepareForLTO || PrepareForThinLTO) {
+@@ -1045,7 +991,6 @@ void PassManagerBuilder::populateModulePassManager(
+   // flattening of blocks.
+   MPM.add(createDivRemPairsPass());
+ 
+-  MPM.add(createSubstitution(Substitution));
+   // LoopSink (and other loop passes since the last simplifyCFG) might have
+   // resulted in single-entry-single-exit or empty blocks. Clean up the CFG.
+   MPM.add(createCFGSimplificationPass(
diff --git a/llvm/lib/Transforms/TraceMalloc/CMakeLists.txt b/llvm/lib/Transforms/TraceMalloc/CMakeLists.txt
new file mode 100644
index 000000000000..5bb153a01572
--- /dev/null
+++ b/llvm/lib/Transforms/TraceMalloc/CMakeLists.txt
@@ -0,0 +1,34 @@
+file(GLOB SOURCES
+TraceMalloc.cpp)
+
+include_directories(SYSTEM ${LLVM_INCLUDE_DIRS})
+link_directories(${LLVM_LIB_DIRS})
+
+set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -DLLVM_MAJOR_VERSION=${LLVM_VERSION_MAJOR}")
+
+# generate MyPass.so
+# add_llvm_pass_plugin must be used with AddLLVM
+add_llvm_pass_plugin(LLVMTraceMalloc
+	${SOURCES}
+)
+
+set_target_properties(LLVMTraceMalloc PROPERTIES
+						RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)
+
+# generate libMyPass.so
+# add_library(MyPass
+#	SHARED
+#	MyPass.cpp
+#)
+
+
+# clang-12 -Xclang -load -Xclang /media/hdisk2/MyPass/libMyPass.so -mllvm -slice -c test.c
+# clang-14 -flegacy-pass-manager -Xclang -load -Xclang /media/hdisk2/MyPass/libMyPass.so -mllvm -slice -c test.c
+
+# for new pass manager, use "-fplugin Bye.so" or "-Xclang -load -Xclang Bye.so" to allow passing cmd arguments.
+# for clang-12, we can also use "-fplugin MyPass.so" to replace "-Xclang ...".
+# for clang-12, use "-fexperimental-new-pass-manager -fplugin xxx -fpass-plugin xxx" to run with new pass manager.
+# use "-O1" for Bye.so because Bye pass does not run on optnone functions.
+# clang-14 -fplugin=Bye.so -fpass-plugin=Bye.so -mllvm -wave-goodbye -c ../test.c
+
+# using opt, both "-load xxx" and "--load-pass-plugin=xxx" should be used to use cmd arguments
diff --git a/llvm/lib/Transforms/TraceMalloc/TraceMalloc.cpp b/llvm/lib/Transforms/TraceMalloc/TraceMalloc.cpp
new file mode 100644
index 000000000000..fbaf494bf599
--- /dev/null
+++ b/llvm/lib/Transforms/TraceMalloc/TraceMalloc.cpp
@@ -0,0 +1,256 @@
+#include "llvm-c/Core.h"
+#include "llvm/ADT/StringRef.h"
+#include "llvm/Analysis/AliasAnalysis.h"
+#include "llvm/Analysis/BasicAliasAnalysis.h"
+#include "llvm/Analysis/CallGraph.h"
+#include "llvm/Analysis/DDG.h"
+#include "llvm/Analysis/DOTGraphTraitsPass.h"
+#include "llvm/Analysis/LoopInfo.h"
+#include "llvm/Analysis/ScalarEvolution.h"
+#include "llvm/Analysis/TargetLibraryInfo.h"
+#include "llvm/Bitcode/BitcodeWriter.h"
+#include "llvm/Bitcode/LLVMBitCodes.h"
+#include "llvm/Bitstream/BitstreamWriter.h"
+#include "llvm/IR/BasicBlock.h"
+#include "llvm/IR/DerivedTypes.h"
+#include "llvm/IR/IRBuilder.h"
+#include "llvm/IR/CFG.h"
+#include "llvm/IR/Dominators.h"
+#include "llvm/IR/Function.h"
+#include "llvm/IR/InstrTypes.h"
+#include "llvm/IR/Instruction.h"
+#include "llvm/IR/Instructions.h"
+#include "llvm/IR/Intrinsics.h"
+#include "llvm/IR/LegacyPassManager.h"
+#include "llvm/IR/LLVMContext.h"
+#include "llvm/IR/Module.h"
+#include "llvm/IR/ModuleSummaryIndex.h"
+#include "llvm/IR/PassManager.h"
+#include "llvm/IR/Type.h"
+#include "llvm/IR/Value.h"
+#include "llvm/Pass.h"
+#include "llvm/Passes/PassBuilder.h"
+#include "llvm/Passes/PassPlugin.h"
+#include "llvm/Support/Casting.h"
+#include "llvm/Support/CommandLine.h"
+#include "llvm/Support/ErrorHandling.h"
+#include "llvm/Support/InstructionCost.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/Transforms/IPO/PassManagerBuilder.h"
+
+#include <stack>
+
+using namespace llvm;
+using namespace std;
+
+namespace {
+struct LLVMTraceMallocOnFunction : public FunctionPass {
+public:
+    static char ID;
+    
+    LLVMTraceMallocOnFunction() : FunctionPass(ID) {}
+    
+    bool runOnFunction(Function& F) override {
+        bool Ret = false;
+
+        // if (F.getName() != "proc_do_submiturb") return false;
+        // errs() << "[START] Analyze function: " << F.getName() << "\n\n";
+        // errs() << F << "\n";
+        
+        for (auto &BB : F) {
+            stack<CallInst*> Found;
+
+            for (auto &I : BB) {
+                const Type *RetType = nullptr;
+                BasicBlock *CurrentBB = nullptr;
+                Instruction *InsertBefore = nullptr;
+
+                if (auto *CallI = dyn_cast<CallInst>(&I)) {
+                    Function *CalledFunc = CallI->getCalledFunction();
+                    if (CalledFunc &&
+                        (CalledFunc->getName() == "kmalloc" || 
+                         CalledFunc->getName() == "kmem_cache_alloc_trace")) {
+                        // errs() << "[I] Found a call to " << CalledFunc->getName()
+                        //      << ": " << *CallI << "\n";
+
+                        Found.push(CallI);
+                    }
+                }
+                else if (auto *CastI = dyn_cast<CastInst>(&I)) {
+                    if (!Found.empty() && Found.top() == CastI->getOperand(0)) {
+                        // errs() << "[I] Found a cast inst: " << *CastI << "\n";
+                        
+                        RetType = getPointedType(CastI->getDestTy());
+                        CurrentBB = CastI->getParent();
+                        InsertBefore = CastI;
+
+                        Found.pop();
+                    }
+                }
+                else if (auto *StoreI = dyn_cast<StoreInst>(&I)) {
+                    if (!Found.empty() && Found.top() == StoreI->getOperand(0)) {
+                        // errs() << "[I] Found a store inst: " << *StoreI << "\n";
+
+                        RetType = getPointedType(StoreI->getPointerOperandType()->getNonOpaquePointerElementType());
+                        CurrentBB = StoreI->getParent();
+                        InsertBefore = StoreI;
+
+                        Found.pop();
+                    }
+                }
+
+                if (RetType && CurrentBB) {
+                    if (RetType->isStructTy()) {
+                        errs() << "[F] Function: " << F.getName() << "\n";
+                        errs() << "[I] Struct type: " << RetType->getStructName() << "\n";
+
+                        if (Int32Ty == nullptr && GVPid == nullptr) {
+                            Int32Ty = IntegerType::getInt32Ty(CurrentBB->getContext());
+                            GVPid = new GlobalVariable(*CurrentBB->getModule(), PointerType::get(static_cast<Type*>(Int32Ty), 0), false, GlobalValue::ExternalLinkage, nullptr, "focus_pid");
+                        }
+
+                        if (RetType->getStructName() != "struct.external_name")
+                            Ret = insertCallToPrintk(CurrentBB, RetType->getStructName(), InsertBefore);
+                    
+                        errs() << "[=] Insert result: " << Ret << "\n\n";
+                    }
+                }
+            }
+        }
+        // errs() << "[ END ] Analyze function: " << F.getName() << "\n\n";
+        // errs() << F << "\n";
+        return Ret;
+    }
+private:
+    IntegerType *Int32Ty = nullptr;
+    GlobalVariable *GVPid = nullptr;
+
+    const Type *getPointedType(const Type *TargetType) const {
+        if (TargetType->isPointerTy()) {
+            if(auto *CallerPtrTy = dyn_cast<PointerType>(TargetType)) {
+                // errs() << "[I] Target type cast to PointerType: " << CallerPtrTy->getTypeID() << "\n";
+                const Type *CalleeType = CallerPtrTy->getNonOpaquePointerElementType();
+                // errs() << "[I] Target type cast to PointerType: " << CalleeType->getTypeID() << "\n";
+
+                return CalleeType;
+            }
+        }
+        return nullptr;
+    }
+
+    bool insertCallToPrintk(BasicBlock *KmallocBB, const StringRef &stName, Instruction *instToInsert) const {
+        Twine printStr(stName+StringRef("\n"));
+
+        Function *PrintkFunc = KmallocBB->getModule()->getFunction("_printk");
+        // FunctionType *PrintkTy = FunctionType::get(Type::getInt32Ty(KmallocBB->getContext()), {Type::getInt8PtrTy(BB->getContext())}, true);
+        
+        // FunctionCallee PrintkFunc = KmallocBB->getModule()->getOrInsertFunction("_printk", PrintkTy);
+        if (PrintkFunc == nullptr) {
+            errs() << "[!] Cannot find _printk\n";
+            return false;
+        }
+
+        Function *GetCurrentFunc = KmallocBB->getModule()->getFunction("get_current");
+        if (GetCurrentFunc == nullptr) {
+            errs() << "[!] Cannot find get_current\n";
+            return false;
+        }
+
+        Function *GetPidFunc = KmallocBB->getModule()->getFunction("task_pid_nr");
+        if (GetPidFunc == nullptr) {
+            errs() << "[!] Cannot find task_pid_nr\n";
+            return false;
+        }
+
+        // get the right position to insert
+        while (!isa<StoreInst>(instToInsert) &&
+             !isa<ICmpInst>(instToInsert) &&
+             !isa<ReturnInst>(instToInsert))
+            instToInsert = instToInsert->getNextNode();
+
+        while (isa<StoreInst>(instToInsert))
+            instToInsert = instToInsert->getNextNode();
+
+        errs() << "[I] Insert at: " << *instToInsert << "\n";    
+        BasicBlock *NextBB = KmallocBB->splitBasicBlock(instToInsert, "NextBB");
+        BasicBlock *PrintkBB = BasicBlock::Create(KmallocBB->getContext(), "PrintkBB", KmallocBB->getParent(), NextBB);
+        // KmallocBB->setName("KmallocBB");
+
+        KmallocBB->getTerminator()->eraseFromParent();
+
+        // get Builder
+        IRBuilder<> KmallocBuilder(KmallocBB);
+        IRBuilder<> PrintkBuilder(PrintkBB);
+
+        // create Call to Func
+        CallInst *CallPrintkInst = PrintkBuilder.CreateCall(PrintkFunc, {PrintkBuilder.CreateGlobalStringPtr(printStr.str())});
+        if (CallPrintkInst == nullptr) {
+            errs() << "[!] Cannot create call to printk\n";
+            return false;
+        }
+
+        CallInst *CallGetCurrentInst = KmallocBuilder.CreateCall(GetCurrentFunc);
+        if (CallGetCurrentInst == nullptr) {
+            errs() << "[!] Cannot create call to current\n";
+            return false;
+        }
+
+        Value *RetTask = CallGetCurrentInst;
+        
+        CallInst *CallGetPidInst = KmallocBuilder.CreateCall(GetPidFunc, {RetTask});
+        if (CallGetPidInst == nullptr) {
+            errs() << "[!] Cannot create call to task_pid_nr\n";
+            return false;
+        }
+
+        // get global variable $focus_pid
+        LoadInst *LoadPid = KmallocBuilder.CreateLoad(Int32Ty, GVPid);
+        LoadPid->setMetadata(NextBB->getModule()->getMDKindID("nosanitize"), MDNode::get(NextBB->getContext(), None));
+        Value *VPid = KmallocBuilder.CreateZExt(LoadPid, KmallocBuilder.getInt32Ty());
+
+        Value *CPid = CallGetPidInst;
+        
+        // // insert cmp inst to $NextBB
+        Value *CmpPidInst = KmallocBuilder.CreateCmp(CmpInst::ICMP_EQ, CPid, VPid);
+        if (CmpPidInst == nullptr) {
+            errs() << "[!] Cannot create cmp\n";
+            return false;
+        }
+
+        KmallocBuilder.CreateCondBr(CmpPidInst, PrintkBB, NextBB);
+        PrintkBuilder.CreateBr(NextBB);
+
+        return true;
+    }
+};
+} // namespace
+
+namespace {
+struct LLVMTraceMallocOnModule : public ModulePass {
+public:
+    static char ID;
+    
+    LLVMTraceMallocOnModule() : ModulePass(ID) {}
+    
+    bool runOnModule(Module& M) override {
+        for (auto &F : M) {
+            errs() << "Found a func: " << F.getName() << "\n";
+        }
+        return false;
+    }
+};
+} // namespace
+
+char LLVMTraceMallocOnFunction::ID = 0;
+static RegisterPass<LLVMTraceMallocOnFunction> XF("trace-malloc-function", "Trace Malloc Function Pass");
+static llvm::RegisterStandardPasses YF(
+    llvm::PassManagerBuilder::EP_EarlyAsPossible,
+    [](const llvm::PassManagerBuilder &KmallocBuilder,
+       llvm::legacy::PassManagerBase &PM) { PM.add(new LLVMTraceMallocOnFunction()); });
+
+// char LLVMTraceMallocOnModule::ID = 0;
+// static RegisterPass<LLVMTraceMallocOnModule> XM("trace-malloc-module", "Trace Malloc Module Pass");
+// static llvm::RegisterStandardPasses YM(
+//     llvm::PassManagerBuilder::EP_EnabledOnOptLevel0,
+//     [](const llvm::PassManagerBuilder &KmallocBuilder,
+//        llvm::legacy::PassManagerBase &PM) { PM.add(new LLVMTraceMallocOnModule()); });
